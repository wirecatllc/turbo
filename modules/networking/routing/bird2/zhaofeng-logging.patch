diff --git a/proto/bgp/packets.c b/proto/bgp/packets.c
index c3bd600a..3cb4f75a 100644
--- a/proto/bgp/packets.c
+++ b/proto/bgp/packets.c
@@ -891,10 +891,10 @@ bgp_rx_open(struct bgp_conn *conn, byte *pkt, uint len)
 #define WITHDRAW(msg, args...) \
   ({ REPORT(msg, ## args); s->err_withdraw = 1; return; })
 
-#define BAD_AFI		"Unexpected AF <%u/%u> in UPDATE"
-#define BAD_NEXT_HOP	"Invalid NEXT_HOP attribute"
-#define NO_NEXT_HOP	"Missing NEXT_HOP attribute"
-#define NO_LABEL_STACK	"Missing MPLS stack"
+#define BAD_AFI		"Unexpected AF <%u/%u> in UPDATE."
+#define BAD_NEXT_HOP	"Invalid NEXT_HOP attribute %I (%s)."
+#define NO_NEXT_HOP	"Missing NEXT_HOP attribute."
+#define NO_LABEL_STACK	"Missing MPLS stack."
 
 
 static void
@@ -914,7 +914,7 @@ bgp_apply_next_hop(struct bgp_parse_state *s, rta *a, ip_addr gw, ip_addr ll)
       nbr = neigh_find(&p->p, ll, p->neigh->iface, 0);
 
     if (!nbr || (nbr->scope == SCOPE_HOST))
-      WITHDRAW(BAD_NEXT_HOP);
+      WITHDRAW(BAD_NEXT_HOP, gw, "missing or local neighbor");
 
     a->dest = RTD_UNICAST;
     a->nh.gw = nbr->addr;
@@ -924,7 +924,7 @@ bgp_apply_next_hop(struct bgp_parse_state *s, rta *a, ip_addr gw, ip_addr ll)
   else /* GW_RECURSIVE */
   {
     if (ipa_zero(gw))
-      WITHDRAW(BAD_NEXT_HOP);
+      WITHDRAW(BAD_NEXT_HOP, gw, "zero address");
 
     rtable *tab = ipa_is_ip4(gw) ? c->igp_table_ip4 : c->igp_table_ip6;
     s->hostentry = rt_get_hostentry(tab, gw, ll, c->c.table);
@@ -1044,6 +1044,8 @@ bgp_use_gateway(struct bgp_export_state *s)
 static void
 bgp_update_next_hop_ip(struct bgp_export_state *s, eattr *a, ea_list **to)
 {
+  struct bgp_proto *p = s->proto;
+
   if (!a || !bgp_use_next_hop(s, a))
   {
     if (bgp_use_gateway(s))
@@ -1086,16 +1088,23 @@ bgp_update_next_hop_ip(struct bgp_export_state *s, eattr *a, ea_list **to)
 
   /* Forbid zero next hop */
   if (ipa_zero(nh[0]) && ((len != 32) || ipa_zero(nh[1])))
-    WITHDRAW(BAD_NEXT_HOP);
+    WITHDRAW(BAD_NEXT_HOP, nh[0], "zero address");
 
   /* Forbid next hop equal to neighbor IP */
-  if (ipa_equal(peer, nh[0]) || ((len == 32) && ipa_equal(peer, nh[1])))
-    WITHDRAW(BAD_NEXT_HOP);
+  if (ipa_equal(peer, nh[0]) || ((len == 32) && ipa_equal(peer, nh[1]))) {
+    if (p->local_as != p->remote_as) {
+      WITHDRAW(BAD_NEXT_HOP, nh[0], "equals neighbor address");
+    } else {
+      // Quietly drop the route (expected in my RR setup)
+      s->err_withdraw = 1;
+      return;
+    }
+  }
 
   /* Forbid next hop with non-matching AF */
   if ((ipa_is_ip4(nh[0]) != bgp_channel_is_ipv4(s->channel)) &&
       !s->channel->ext_next_hop)
-    WITHDRAW(BAD_NEXT_HOP);
+    WITHDRAW(BAD_NEXT_HOP, nh[0], "wrong address family");
 
   /* Just check if MPLS stack */
   if (s->mpls && !bgp_find_attr(*to, BA_MPLS_LABEL_STACK))
@@ -1167,7 +1176,7 @@ bgp_decode_next_hop_ip(struct bgp_parse_state *s, byte *data, uint len, rta *a)
     ad->length = 16;
 
   if ((bgp_channel_is_ipv4(c) != ipa_is_ip4(nh[0])) && !c->ext_next_hop)
-    WITHDRAW(BAD_NEXT_HOP);
+    WITHDRAW(BAD_NEXT_HOP, nh[0], "wrong address family");
 
   // XXXX validate next hop
 
@@ -1248,7 +1257,7 @@ bgp_decode_next_hop_vpn(struct bgp_parse_state *s, byte *data, uint len, rta *a)
     bgp_parse_error(s, 9);
 
   if ((bgp_channel_is_ipv4(c) != ipa_is_ip4(nh[0])) && !c->ext_next_hop)
-    WITHDRAW(BAD_NEXT_HOP);
+    WITHDRAW(BAD_NEXT_HOP, nh[0], "wrong address family");
 
   // XXXX validate next hop
 
